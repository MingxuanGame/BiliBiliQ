# flake8: noqa: E501
import re
import ast as a
from pathlib import Path
from typing import Callable, List, Optional, Tuple, cast

PYDANTIC_HEADER = '''"""
Generated by generator/gen_pydantic.py. DO NOT EDIT!
isort:skip_file
"""
import builtins
from typing import List, Dict, Any, Optional
from pydantic import BaseModel
from enum import Enum
from datetime import datetime
'''


def generate_pydantic_from_pyi(file: Path, logger: Callable = print) -> None:
    logger(f"Generate pydantic models of the file {file}")
    with open(file, "r", encoding="utf-8") as f:
        source = f.read()
    code = PYDANTIC_HEADER

    def _parse_enum(code: str) -> List[str]:
        def _parse_docstring(code: str, class_real_name: str) -> str:
            index = code.index(f"class {class_real_name}")
            end = code.index(f"global___{class_real_name}") - 1
            class_code = code[index:end].split("\n")
            return class_code[1]

        generated_code = []
        for class_name, class_real_name in re.findall(
            (
                r"class _(\w+)\(google\.protobuf\.internal"
                r"\.enum_type_wrapper\._EnumTypeWrapper"
                r"\[_(\w+)\.ValueType\], builtins.type\):"
            ),
            code,
        ):
            index = code.index(f"class _{class_name}")
            end = code.index(f"class {class_real_name}") - 1
            class_code = code[index:end].split("\n")
            generated_class_code = (
                f"class {class_real_name}(str, Enum):"
                f"\n{_parse_docstring(code, class_real_name)}\n"
            )
            for line in class_code:
                if (
                    not line  # 空格
                    or line.startswith("class")  # 类定义
                    or "DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor"
                    in line
                ):
                    continue
                if '"' not in line:
                    name = line.split(":")[0].strip()
                    generated_class_code += f"    {name}='{name}'\n"
                else:
                    generated_class_code += line + "\n"
            generated_code.append(generated_class_code)
        return generated_code

    def _parse_message(
        code: str, super_class: Optional[str] = None
    ) -> Tuple[List[str], List[str], List[str]]:
        cache_generated_code = []
        need_import = []
        need_forward = []

        def _parse_type(
            type_: str,
            need_import: List[str],
            need_forward: List[str],
            self_name: str,
            super_name: Optional[str] = None,
        ) -> str:
            if (
                "google.protobuf.internal.containers."
                "RepeatedCompositeFieldContainer"
            ) in type_:
                type_ = f"List[{type_[68:-1]}]"
            elif (
                "google.protobuf.internal.containers."
                "RepeatedScalarFieldContainer"
            ) in type_:
                type_ = f"List[{type_[65:-1]}]"
            elif "google.protobuf.internal.containers.MessageMap" in type_:
                key, type__ = type_[47:-1].split(",")
                type_ = f"Dict[{key},{_parse_type(type__[1:], need_import, need_forward, self_name, super_name).replace('=None', '')}]"  # noqa:E501
            elif "google.protobuf.internal.containers.ScalarMap" in type_:
                key, type__ = type_[46:-1].split(",")
                type_ = f"Dict[{key},{_parse_type(type__[1:], need_import, need_forward, self_name, super_name).replace('=None', '')}]"  # noqa:E501
            if "google.protobuf.wrappers_pb2.Int32Value" in type_:
                type_ = "int"
            elif "google.protobuf.any_pb2.Any" in type_:
                type_ = "Any"
            elif "google.protobuf.timestamp_pb2.Timestamp" in type_:
                type_ = "datetime"
            if f"{self_name}." in type_ or (
                self_name and f"{super_name}." in type_
            ):
                type_ = type_.replace('.', '_')
            if super_name and super_name in type_:
                type_ = type_.replace(type_, f"{super_name}.{type_}")
            if "global___" in type_:
                type_ = type_.replace("global___", "")
                if (
                    "ValueType" not in type_
                    and "List" not in type_
                    and "Dict" not in type_
                ):
                    if "_" in type_:
                        if not super_name:
                            need_forward.append(f"{self_name}.{type_}")
                        else:
                            need_forward.append(type_)
                    else:
                        need_forward.append(type_)
                    type_ = f'Optional["{type_}"]=None'
                elif "List" in type_ or "Dict" in type_:
                    type_ = f'"{type_}"'
            if "ValueType" in type_:
                type_ = type_[:-10]
            if "bilibili." in type_:
                parts = type_.split(".")
                parts[-2] += "_model"
                need_import.append(".".join(parts[:-1]))
                is_list = "List[" in type_
                type_ = f"bilibiliq.internal.pb.{('.'.join(parts)).replace('List[','')}"
                if is_list:
                    type_ = f"List[{type_}"
            if type_ == self_name:
                type_ = f'Optional["{type_}"]=None'

            return type_

        for class_name in re.findall(
            (
                r"@typing_extensions\.final\nclass (\w+)"
                r"\(google\.protobuf\.message\.Message\):"
            ),
            code,
        ):
            index = code.index(
                f"class {class_name}(google.protobuf.message.Message):"
            )
            end = code.index(f"global___{class_name} = {class_name}") - 1
            class_code = code[index:end]
            generated_class_code = f"class {class_name}(BaseModel):\n"
            ast_class = cast(a.ClassDef, a.parse(class_code).body[0])

            def _add_line(line: str) -> None:
                nonlocal generated_class_code
                generated_class_code += f"    {line}\n"

            body = ast_class.body
            for i, ast in enumerate(body):
                if isinstance(ast, a.Expr):
                    # docstrings
                    _add_line(f'"""{ast.value.value}"""')  # type: ignore
                elif isinstance(ast, a.AnnAssign):
                    name: str = ast.target.id  # type: ignore
                    if (
                        name in {"builtins", "DESCRIPTOR"}
                        or name.upper() == name
                    ):
                        continue
                    type_ = _parse_type(
                        a.unparse(ast.annotation),
                        need_import,
                        need_forward,
                        class_name,
                        super_class,
                    )
                    _add_line(f"{name}: {type_}")
                elif isinstance(ast, a.FunctionDef):
                    name = ast.name
                    if name in {
                        "__init__",
                        "HasField",
                        "ClearField",
                        "WhichOneof",
                    }:
                        continue
                    type_ = _parse_type(a.unparse(ast.returns), need_import, need_forward, class_name, super_class)  # type: ignore
                    _add_line(f"{name}: {type_}")
                    _add_line(
                        f'"""{ast.body[0].value.value}"""'  # type: ignore
                    )
                elif isinstance(ast, a.ClassDef):
                    name = ast.name
                    if not ast.bases or ast.keywords:
                        continue
                    if len(ast.bases) == 2:
                        # 枚举
                        _add_line(
                            f"class {class_name}_"
                            f"{name[1:len(name)-15]}(str, Enum):"
                        )
                        for enum_ast in ast.body:
                            if isinstance(enum_ast, a.AnnAssign):
                                name_ = enum_ast.target.id  # type: ignore
                                if name_ == "DESCRIPTOR":
                                    continue
                                _add_line(f"    {name_}='{name_}'")
                            elif isinstance(enum_ast, a.Expr):
                                _add_line(
                                    '    '
                                    f'"""{enum_ast.value.value}"""'  # type: ignore
                                )
                    elif (
                        len(ast.bases) == 1
                        and a.unparse(ast.bases[0])
                        == "google.protobuf.message.Message"
                        and not name.endswith("Entry")
                    ):
                        # 子消息
                        sub_messages, sub_need_import, _ = _parse_message(
                            f"{a.unparse(ast)}\nglobal___{name} = {name}",
                            class_name,
                        )
                        for sub_message in sub_messages:
                            sub_message = sub_message.split("\n")
                            _add_line(
                                sub_message[0].replace(
                                    name, f"{class_name}_{name}"
                                )
                            )
                            for line in sub_message[1:]:
                                _add_line(f"{line}")
                        need_import.extend(sub_need_import)

            need_forward.append(class_name)
            cache_generated_code.append(generated_class_code)
        return cache_generated_code, need_import, need_forward

    enum_code = _parse_enum(source)
    model_code, imports, forwards = _parse_message(source)
    imports = set(imports)
    forwards = set(forwards)
    forward_code = []
    for import_ in imports:
        code += (
            f"import bilibiliq.internal.pb.{import_.replace('List[', '')}\n"
        )
    for forward in forwards:
        forward_code.append(f"{forward}.update_forward_refs()")
    code += "".join(enum_code)
    code += "".join(model_code)
    code += "\n".join(forward_code)
    logger(f"Model count: {len(model_code)}")
    logger(f"Enum count: {len(enum_code)}")
    logger(f"Import count: {len(imports)}")
    logger(f"Forward count: {len(forwards)}")
    save_path = file.parent / f"{file.stem}_model.py"
    with open(save_path, "w", encoding="utf-8") as f:
        f.write(code)
    logger(f"Saved {save_path}")


if __name__ == "__main__":
    for file in Path("bilibiliq/internal/pb").rglob("*.pyi"):
        generate_pydantic_from_pyi(file)
